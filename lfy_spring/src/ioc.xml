<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">



    <!--实验1：注册一个Person对象，Spring会自动创建这个Person对象-->
    <!--
        一个Bean标签可以注册一个组件（对象，类）
        class,写要注册的全类名
        id,这个对象的唯一标识
    -->
    <bean id="person01" class="com.mmz.Person">
        <!--使用property标签为Person对象赋值-->
        <property name="lastName" value="张三"></property>
        <property name="age" value="18"></property>
        <property name="email" value="zhangsan@163.com"></property>
        <property name="gender" value="男"></property>

    </bean>

    <bean id="person02" class="com.mmz.Person">
        <!--使用property标签为Person对象赋值-->
        <property name="lastName" value="张三丰"></property>
        <property name="age" value="180"></property>
        <property name="email" value="zhangsanfeng@163.com"></property>
        <property name="gender" value="仙"></property>

    </bean>

    <bean id="person03" class="com.mmz.Person">
    <!--调用有参构造器为Person对象赋值-->
    <constructor-arg name="lastName" value="zhaomin"></constructor-arg>
    <constructor-arg name="age" value="28"></constructor-arg>
    <constructor-arg name="email" value="zhaomin@163.com"></constructor-arg>
    <constructor-arg name="gender" value="女"></constructor-arg>

    </bean>


    <!--可以省略name属性，但是严格按照构造器参数的位置-->
    <!--如果重载可以使用Type指定参数的类型-->
    <bean id="person04" class="com.mmz.Person">
        <!--调用有参构造器为Person对象赋值-->
        <constructor-arg value="zhangwuji"></constructor-arg>
        <constructor-arg value="29"></constructor-arg>
        <constructor-arg value="zhangwuji@163.com"></constructor-arg>
        <constructor-arg value="男"></constructor-arg>

    </bean>

    <!--通过p名称空间为bean赋值,名称空间是防止标签重复-->
    <bean id="person05" class="com.mmz.Person"
          p:lastName="gumin"
          p:age="26"
          p:email="gumin@163.com"
          p:gender="女">
    </bean>


    <!--实验4：为各种不同类型的配置文件赋值：
        测试赋值null值、
        引用类型赋值（引用其他的Bean，引用内部的Bean）、
        集合类型赋值（List/Map/Properties）、
        util名称空间创建集合类型的bean
        级联属性赋值
        -->

    <!--赋值null值-->
    <bean id="person06" class="com.mmz.Person">
        <!--lastName = "null"-->
        <!--
        <property name="lastName" value="null"></property>
        -->
        <!--进行复杂的赋值-->
        <property name="lastName">
            <null></null>
        </property>
    </bean>

    <!--引用赋值-->
    <bean id="car01" class="com.mmz.Car" p:price="2000000" p:name="BMW" p:color="red">
    </bean>

    <bean id="person07" class="com.mmz.Person">
        <property name="car" ref="car01"></property>
    </bean>

    <!--引用内部Bean，其中内部Bean的ID没有作用，不能被获取到-->
    <bean id="person08" class="com.mmz.Person">
        <property name="car">
            <bean id="car02" class="com.mmz.Car">
                <property name="name" value="Auto"></property>
                <property name="color" value="yellow"></property>
                <property name="price" value="3500"></property>
            </bean>
        </property>
    </bean>

    <bean id="book01" class="com.mmz.Book">
        <property name="author" value="Hanmnwell"></property>
        <property name="bookName" value="Oldman and Sea"></property>
    </bean>

    <!--为list类型赋值,使用list标签-->
    <bean id="person09" class="com.mmz.Person">
        <property name="books">
            <!--list 标签类似于 list = new ArrayList()-->
            <list>
                <!--list的标签体中添加每一个元素-->
                <bean id="book02" class="com.mmz.Book" p:author="Andy" p:bookName="Great Times">
                </bean>

                <ref bean="book01"></ref>
            </list>
        </property>
    </bean>

    <!--为map类型赋值,使用map标签-->
    <bean id="person10" class="com.mmz.Person">
        <property name="maps">
            <!--map 标签类似于 map = new LinkedHashMap()-->
            <map>
                <entry key="k1" value="v1"></entry>
                <entry key="k2" value="18"></entry>
                <entry key="k3" value-ref="book01"></entry>
                <entry key="k4">
                    <bean id="book03" class="com.mmz.Book" p:author="Cook" p:bookName="Time and Dinner">
                    </bean>
                </entry>
            </map>
        </property>

    </bean>

    <!--为properties类型赋值,使用props标签-->
    <bean id="person11" class="com.mmz.Person">
        <property name="properties">
            <props>
                <prop key="username">root</prop>
                <prop key="password">1234455</prop>
            </props>
        </property>
    </bean>

    <!--util名称空间创建集合类型的bean:方便别人引用-->
    <bean id="person12" class="com.mmz.Person">
        <property name="maps" ref="myMap"></property>
    </bean>
    <util:map id="myMap">
        <entry key="k1" value="v1"></entry>
        <entry key="k2" value="18"></entry>
        <entry key="k3" value-ref="book01"></entry>
        <entry key="k4">
            <bean id="book03" class="com.mmz.Book" p:author="Cook" p:bookName="Time and Dinner">
            </bean>
        </entry>

    </util:map>

    <!--级联属性赋值:属性的属性,因为是引用所以原来的值也会被修改-->
    <bean id="person13" class="com.mmz.Person">
        <!--为Car赋值的时候，改变Car的价格-->
        <property name="car" ref="car01"></property>
        <!---->
        <property name="car.price" value="900000"></property>
    </bean>








    <!--
    实验5：通过继承实现bean配置信息的重用
    实验6：通过abstract属性创建一个模板bean
    实验7：bean之间的依赖

    -->

    <!--实验5：通过继承实现bean配置信息的重用-->
    <!--实验6：abstract="true" 这个Bean配置是一个抽象的，不能获取它的实例，只能被别人用来继承-->
    <bean id="person14" class="com.mmz.Person" abstract="true">
        <property name="lastName" value="翠花"></property>
        <property name="age" value="18"></property>
        <property name="email" value="cuihua@163.com"></property>
        <property name="gender" value="小仙女"></property>

    </bean>

    <!--parent:指定当前bean的配置信息继承于哪一个-->
    <bean id="person15" class="com.mmz.Person" parent="person14">
        <property name="lastName" value="如花"></property>
    </bean>



    <!--实验7：bean之间的依赖,原本是按照创建的顺序配置Bean的顺序-->
    <!--可以改变其创建的顺序，depends-on后面跟bean-->
    <bean id="person" class="com.mmz.Person" depends-on="car"></bean>
    <bean id="car" class="com.mmz.Car"></bean>
    <bean id="book" class="com.mmz.Book"></bean>



    <!--非常重要的实验：

        实验8：测试bean的作用域，分别创建单实例和多实例的bean
        实验9：配置通过静态工厂创建的bean，实例工厂方法创建的bean，FactoryBean

    -->









</beans>